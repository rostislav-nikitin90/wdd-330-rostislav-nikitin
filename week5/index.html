<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WDD 330 Portfolio - Week 05 Page</title>
    <meta name="author" content="Rostislav Nikitin">
    <link rel="stylesheet" href="css/week05page.css">
  </head>
  <body>
    <h1>WDD 330 Portfolio</h1>
    <h2>Week05</h2>
    <h3>Readings:</h3>
    <h3>JavaScript: Novice to Ninja 2nd Edition</h3>
    <h4>Chapter 10: Testing and Debugging</h4>
    <p>Notes:</p>
    <p>Errors and bugs in programming are inevitable in code, and it's better to find them sooner rather than later to minimize their occurrence and find ways to quickly identify and fix them.
        Testing is done to see if the code contains errors, it is the process of finding bugs and errors, while debugging is done to find and fix those errors during testing.
    </p>
    <p>Errors are caused when something goes wrong in a program. They are usually caused by one of the following:
    </p>
    <ul class="errorList">
        <li>System error ― there's a problem with the system or external devices with which the program is interacting.</li>
        <li>Programmer error ― the program contains incorrect syntax or faulty logic; it could even be as simple as a typo.</li>
        <li>User error ― the user has entered data incorrectly, which the program is unable to handle.</li>
    </ul>
    <p>The exception is an error that produces a return value that can then be used by the program to handle the error. For example, an attempt to call a method that doesn't exist will result in a reference error that raises an exception, as seen in the example below when trying to call the mythical unicorn() function:
    </p>
    <p>unicorn();</p>
    <p><< ReferenceError: unicorn is not defined</p>
    <p>An exception will also generate a stack trace. This is a sequence of function or method calls that lead to the point where the error occured. Often, it's not just the call to a single function or method that causes an error. The stack trace will work backwards from the point at which the error occurred to determine the original function or method that started the sequence. 
      The example below shows how a stack trace can help find the source of the error:
    </p>
    <div class="stackTraceExample">
      <p>function three(){ unicorn(); }</p>
      <p>function two(){ three(); }</p>
      <p>function one(){ two(); }</p>
      <p>one();</p>
      <p><< index.html:13 Uncaught ReferenceError: unicorn is not defined</p>
      <p>at three (index.html:13)</p>
      <p>at two (index.html:17)</p>
      <p>at one (index.html:21)</p>
      <p>at index.html:24`</p>
    </div>
    <p>There are three functions in this example: function one() invokes function two(), which then invokes function three(). Function three() then invokes the unicorn() function that doesn't exist and causes an error. The stack trace can be used to work backwards and see that this error was caused by invoking the function one() in the first place.
    </p>
    <p>A warning may appear if there is an error in the code that is not enough to cause the program to crash. This means that the program will continue to run after the warning and the issue that produced the warning may cause the program to continue running incorrectly. An example of a mistake that could cause a warning is assigning a value to a variable that's undeclared:
    </p>
    <p>pi = 3.142;</p>
    <p><< JavaScript Warning: assignment to undeclared variable</p>
    <p>Warnings and exceptions are presented differently in various environments. Some browsers display a small icon in the corner of the browser window to indicate that an exception or warning has occurred. Others require the console to be open to view any warnings or exceptions.
    </p>
    <p>When a run-time error occurs in the browser, the HTML code will still be displayed, but the JavaScript code will stop running in the background, which is not always obvious at first. If a warning appears, JavaScript will continue to work (although possibly incorrectly).
    </p>
    <p>JavaScript can be put into strict mode using the string "use strict". This can be used in a whole file or just a single function.
      Strict mode produces more exceptions and warnings and prohibits the use of some deprecated features. Strict mode changes previously accepted bad-style coding practices into real errors. Strict mode simply requires the following string to be added to the first line of a JavaScript file:
    </p>
    <p>'use strict';</p>
    <p>This will be picked up by any JavaScript engine that uses strict mode. If the engine does not support strict mode, this string will simply be ignored.
    </p>
    <p>An example in action attempting to assign a value to a variable that is not declared in strict mode will result in an exception instead of a warning:
    </p>
    <p>'use strict';</p>
    <p class="undeclaredVariableInStrictMode">e = 2.718;</p>
    <p><< ReferenceError: e is not defined</p>
    <p>An example of using strict mode on a per-function basis by adding the line inside a function. Strict mode will then only be applied to anything inside that function:
    </p>
    <p>function strictly(){</p>
    <p>'use strict';</p>
    <p>// function code goes here</p>
    <p class="invokingStrictModeExample">In fact, the recommended way to invoke strict mode is to place all your code into a self-invoking function, like so:
    </p>
    <div class="selfInvokingFunction">
      <p>(function() {</p>
      <p>'use strict';</p>
      <p>// All your code would go inside this function</p>
      <p>}());</p>
    </div>
    <p>Placing 'use strict' at the beginning of a file will enforce strict mode on all the JavaScript in the file. And if you're using anybody else's code, there's no guarantee they've coded in strict mode. This technique will ensure that only your code is forced to use strict mode.
    </p>
    <p>Linting tools such as JS Lint, JS Hint, and ES Lint can be used to test the quality of JavaScript code, beyond simply using strict mode to highlight any sloppy programming practices or syntax errors. Linting tools will complain if certain style conventions are not followed, such as how code is indented. 
      They can be very unforgiving and use some opinionated coding conventions, such as not using the ++ and -- increment operators (in the case of JS Lint). Linting tools are also useful for enforcing a programming style guide. This is particularly useful when a programmer is working in a team, as it ensures everybody follows the same conventions.
    </p>
    <p>It's possible to add a linting tool as a text-editor plugin; this will then highlight any sloppy code as you type. Another option is to use an online linting tool that allows a programmer to simply paste onto a page for feedback. Another option is to install linting software on your computer using npm. This can then be run as part of your workflow. 
      Passing a lint test is no guarantee that your code is correct, but it will mean it will be more consistent and less likely to have problems.
    </p>
    <p class=featuredDectectionDefinition>Feature detection is used to determine browser support for a feature. It checks whether a method is supported before calling it, helping to avoid an exception being thrown. This is done using an if statement to check whether an object or method exists before trying to actually call the method.
      For example, a programmer wants to use the shiny new holoDeck API (which doesn't really exist yet), and would wrap any method calls inside the following if block:
    </p>
    <div class="featureDetectionExample">
      <p>if (window.holoDeck) {</p>
      <p>virtualReality.activate();</p>
      <p>}</p>
    </div>
    <p>This ensures that no error occurs if the browser doesn't support the method, because referencing a nonexistent object such as window.virtualReality will return undefined. As it's a falsy value, the if block won't run, but calling the method virtualReality.activate() outside of the if block would cause an exception to be thrown. Feature detection guarantees that the method is only called if it actually exists and fails gracefully, without any exceptions being thrown, if the method doesn't exist.
    </p>
    <p class="basicFormOfDebugging">The most basic form of debugging (the process of finding errors in code and then fixing them) is to use the alert() method to show a dialog at certain points in the code. Because alert() stops a program from running until OK is clicked, it allows to effectively put breakpoints in the code that let the programmer check the value of variables at that point to make sure they match the programmer's expectations. The following example checks to see if a person's age is appropriate:</p>
    <div class="alertMethodExample1">
      <p>function amIOldEnough(age){</p>
      <p>if (age = 12) {</p>
      <p>alert(age);</p>
      <p>return 'No, sorry.';</p>
      <p>} else if (age < 18) {</p>
      <p>return 'Only if you are accompanied by an adult.';</p>
      <p>}</p>
      <p>else {</p>
      <p>return 'Yep, come on in!';</p>
      <p>}</p>
      <p>}</p>
    </div>
    <p>The alert method inside the if block will allow to see the value of the age variable at that point. Once the programmer clicks on OK, he can then check the function returns the correct message.
    </p>
    <p>If you try the example above, you will find that there is a bug in the code:
    </p>
    <p>amIOldEnough(21)</p>
    <p><< 'No, sorry.'</p>
    <p>Passing an argument of 21 should result in the string 'Yep, come on in!' being returned, but it is returning 'No, sorry.' instead. If you tried running the example, you would have seen the alert message show that the value of the variable age is 12, even though the function was passed an argument of 21. Closer inspection then reveals a classic mistake has been made. Instead of checking if the value of age is equal to 12, it was inadvertently assigned it the value of 12! To check for equality, we should use === instead of = which assigns a value to a variable (even inside an if block).
    </p>
    <p>Actually the task is to return the message  'No, sorry.' for all values of age that are less than 12, so the code can be updated to the following:
    </p>
    <div class="alertMethodExample2">
      <p>function amIOldEnough(age){</p>
      <p>if (age < 12) {</p>
      <p>alert(age);</p>
      <p>return 'No, sorry.';</p>
      <p>} else if (age < 18) {</p>
      <p>return 'Only if you are accompanied by an adult.';</p>
      <p>}</p>
      <p>else {</p>
      <p>return 'Yep, come on in!';</p>
      <p>}</p>
      <p>}</p>
    </div>
    <p>Try this again and it works as expected:
    </p>
    <p>amIOldEnough(21)</p>
    <p><< 'Yep, come on in!'</p>
    <p>Using alerts for debugging was the only option in the past, but JavaScript development has progressed since then and their use is discouraged for debugging purposes today.
    </p>
    <p class="consoleObjectDefinition">Most modern JavaScript environments have a console object that provides a number of methods for logging information and debugging and provides access to the browser's debugging console. It's not officially part of the ECMAScript specification, but is well supported in all the major browsers and Node.js.
      The console.log() method outputs a message to the web console. This can be used to log the value of variables at different stages of the program, although it will not actually stop the execution of the program in the same way as alert() does. For example, some console.log() statements can be added to the amIOldEnough() function to log the position in the function as well as the value of the age variable:
    </p>
    <div class="consoleLogExample">
      <p>function amIOldEnough(age){</p>
      <p>console.log(age);</p>
      <p>if (age < 12) {</p>
      <p>console.log(`In the if with ${age}`);</p>
      <p>return 'No, sorry.';</p>
      <p>} else if (age < 18) {</p>
      <p>console.log(`In the else-if with ${age}`);</p>
      <p>return 'Only if you are accompanied by an adult.';</p>
      <p>} else {</p>
      <p>console.log(`In the else with ${age}`);</p>
      <p>return 'Yep, come on in!';</p>
      <p>}</p>
      <p>}</p>
    </div>
    <p>Another option is the browser's built-in debugging tool, which can be used to interactively find and fix bugs in code. It allows the programmer to set breakpoints in your code that will pause it at certain points. He can then see the values of all the variables at those points and modify them. 
      This can be very useful when trying to track down bugs.
    </p>
    <p class="errorObjectDefinition">An error object is created when an exception occurs, or it can be created in the code using a constructor function, like so:
    </p>
    <p>const error = new Error();</p>
    <p>This constructor function takes a parameter that's used as the error message:
    </p>
    <p>const error = new Error('Oops, something went wrong');</p>
    <p>There are seven more error objects used for specific errors, such as TypeError, which is thrown when there is an error in the type of value used. For example, a string is used when a number is expected.
      These error objects can also be used as constructors to create custom error objects:
    </p>
    <p>const error = new TypeError('You need to use numbers in this function');</p>
    <p>All error objects have a number of properties, but they're often used inconsistently across browsers. The only properties that are generally safe to use are:</p>
    <ul>
      <li>The name property returns the name of the error constructor function used as a string, such as 'Error' or 'ReferenceError'.</li>
      <li>The message property returns a description of the error and should be provided as an argument to the Error constructor function.</li>
      <li>The stack property will return a stack trace for that error. This is a non-standard property and it's recommended that it is not safe to use in production sites.</li>
    </ul>
    <p class="throwStatementDefinition">In addition to raising errors, which are automatically thrown by the JavaScript engine, exceptions can be thrown using the throw statement. The throw statement can be applied to any JavaScript expression, causing the execution of the program to stop. 
      For example, all the following lines of code will cause a program to halt:
    </p>
    <p>throw 2;</p>
    <p>throw 'Up';</p>
    <p>throw { toys: 'out of pram' };</p>
    <p>It is best practice, however, to throw an error object. This can then be caught in a catch block.
    </p>
    <p>throw new Error('Something has gone badly wrong!');</p>
    <p>An example of a function named SquareRoot() for finding the square root of a number using the Math.sqrt() method, which actually returns NaN for negative arguments, which is not entirely correct since the answer should be an imaginary number, but they are not supported in JavaScript. 
      This function will throw an error if the user tries to use a negative argument:
    </p>
    <div class="throwStatementExample">
      <p>function squareRoot(number) {</p>
      <p>'use strict';</p>
      <p>if (number < 0) {</p>
      <p class="throwNewRangeError">throw new RangeError('You can't find the square root of negative numbers')</p>
      <p>}</p>
      <p>return Math.sqrt(number);</p>
      <p>};</p>
    </div>
    <p>Let's test it out:</p>
    <p>squareRoot(121);</p>
    <p><< 11</p>
    <p class="sqRoot-1">squareRoot(-1);</p>
    <p><< RangeError: You can't find the square root of negative numbers</p>
    <p class="exceptionHandlingDefinition">When an exception occurs, any errors can be handled by catching the error. Any errors can be hidden from users, but still  identified. The programmer can then handle the error appropriately—perhaps even ignore it—and keep the program running.
      A suspect piece of code that could result in an exception can be wrapped in a try block. This will run the code inside the block as normal, but if an exception occurs it will pass the error object that is thrown onto a catch block. Here's a simple example using our squareRoot() function from earlier:
    </p>
    <div class="exceptionHandlingExample">
      <p>function imaginarySquareRoot(number) {</p>
      <p>'use strict';</p>
      <p>try {</p>
      <p>return String(squareRoot(number));</p>
      <p>} catch(error) {</p>
      <p>return squareRoot(-number)+'i';</p>
      <p>}</p>
      <p>}</p>
    </div>
    <p>The code inside the catch block will only run if an exception is thrown inside the try block. The error object is automatically passed as a parameter to the catch block. This allows the programmer to query the error name, message and stack properties, and deal with it appropriately. In this case, a string representation of an imaginary number is returned:
    </p>
    <p>imaginarySquareRoot(-49) // no error message shown</p>
    <p><< '7i'</p>
    <p class="finallyBlockDefinition">A finally block can be added after a catch block. This will always be executed after the try or catch block, regardless of whether an exception occurred or not. It is useful if the programmer wants some code to run in both cases. He can use this to modify the imaginarySquareRoot() function so that it adds "+ or -" to the answer before returning it:
    </p>
    <div class="finallyBlockExample">
      <p>function imaginarySquareRoot(number) {</p>
      <p>'use strict';</p>
      <p>let answer;</p>
      <p>try {</p>
      <p>answer = String(squareRoot(number));</p>
      <p>} catch(error) {</p>
      <p>answer = squareRoot(-number)+"i";</p>
      <p>} finally {</p>
      <p>return `+ or - ${answer}`;</p>
      <p>}</p>
      <p>}</p>
    </div>
    <p>Test-driven development (TDD) is a process consisting of several stages:
    </p>
    <ol>
      <li>Write tests (that initially fail)</li>
      <li>Write code to pass the tests</li>
      <li>Refactor the code</li>
      <li>Test refactored code</li>
      <li>Write more tests for new features</li>
    </ol>
    <p>After writing a test that fails at first, and then writing code that passes the test, the code is refactored to make it faster, more readable, and eliminate any repetition. The code is continually tested at each stage to make sure it continues to work. 
      This is often referred to as the “red-green-refactor” cycle of TDD, as failing tests are typically shown in red, and passing ones are shown in green.
    </p>
    <p class="testingFrameworksDefinition">Testing frameworks provide a framework for writing meaningful tests and then run them. There are a large number of frameworks available for JavaScript, one of the testing frameworks used is called Jest. 
      It simplifies the creation and running of tests by providing helper methods for common test assertions.
    </p>
    <p>Jest is installed using npm and entering the following comand in a terminal:
    </p>
    <p>npm install -g jest</p>
    <p>This is an example test using Jest. Here the test checks if the squareRoot() function from earlier versions works. As an example, a squareRoot.test.js file could be created and the following code added:
    </p>
    <div class="squareRootTest">
      <p>function squareRoot(number) {</p>
      <p>'use strict';</p>
      <p>if (number < 0) {</p>
      <p>throw new RangeError("You can't find the square root of negative numbers")</p>
      <p>}</p>
      <p>return Math.sqrt(number);</p>
      <p>};</p>
      <p>test('square root of 4 is 2', () => {</p>
      <p>expect(squareRoot(4)).toBe(2);</p>
      <p>});</p>
    </div>
    <p>This file contains the squareRoot() function to be tested, as well as a test() function. The first parameter of the test() function is a string describing what is being tested, in this case that 'square root of 4 is 2'. The second parameter is an anonymous function that contains a function called expect(), which takes the function the programmer is testing as an argument, and returns an expectation object. The expectation object has a number of methods called matchers. In the example above, the matcher is toBe(), which tests to see if the value returned by squareRoot() function is the same as the value provided as an argument (2, in this case). 
      These matchers are named so they read like an English sentence, making them easier to understand (even for non-programmers), and the feedback they provide more meaningful. The example above almost reads as 'expect the square root of 4 to be 2'. It's important to recognize that these are just functions at the end of the day, so they behave in exactly the same way as any other function in JavaScript. 
      This means that any valid JavaScript code can be run inside the test function.
    </p>
    <p>To run this test, it is necessary to navigate to the folder that contains the file squareRoot.test.js and enter the following command:
    </p>
    <p>jest -c {}</p>
    <p>This will run all files that end in 'test.js' within that folder. The -c {} flag at the end is shorthand for 'configuration'. In this case, no additional configuration is needed, so an empty object is passed to it.
    </p>
    <p>If everything is working okay, it should produce the following output:</p>
    <p><< PASS  ./squareRoot.test.js</p>
    <p>✓ square root of 4 is 2 (2ms)</p>
    <table>
      <tr>
        <td>Test Suites:</td>
        <td>1 passed, 1 total</td>
      </tr>
      <tr>
        <td>Tests:</td>
        <td>1 passed, 1 total</td>
      </tr>
      <tr>
        <td>Snapshots:</td>
        <td>0 total</td>
      </tr>
      <tr>
        <td>Time:</td>
        <td>2.996s</td>
      </tr>
    </table>
    <p>This tells that there was 1 test and it passed in a mere 2ms.</p>

    <ul>
      <li class="week5Exercises">
        Week 5 Exercises:
      </li>
      <li>
        <a href="ch10/quiz_ninja_pt10.html" target="_blank">Quiz Ninja Project Part 10</a>
        <p>In this version of the Quiz Ninja Project, the console.log() method is used to log when some of the important functions are called. This will help to make the code in the Quiz Ninja project easier to debug. 
          The main functions in the game are all methods of the game object: game.start(), game.ask(), game.check(event), and game.gameOver(). 
          The following lines of code have been added to the beginning of the relevant functions:
        </p>
        <p>console.log('start() invoked');</p>
        <p>console.log('ask() invoked');</p>
        <p>console.log('check(event) invoked');</p>
        <p>console.log('gameOver() invoked');</p>
        <p>These declarations will log a message in the console when each method is invoked, so that the programmer can see where the program is in its runtime. There will be no impact on the player, though, as the console is just being used.
        </p>
        <p>When trying to play the quiz with the console open in my browser, I can see the messages logged in the console while the program is running, as in the screenshot shown below:
        </p>
        <div>
          <img src="images/ScreenShot-20220205211058.png" alt="Playing Quiz Ninja with the console open">
        </div>
      </li>
    </ul>
  </body>
</html>